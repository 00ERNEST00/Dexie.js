{"version":3,"sources":["../src/syncable-connect.js","../src/PersistedContext.js","../src/get-or-create-sync-node.js","../src/enqueue.js","../src/save-to-uncommitted-changes.js","../src/bulk-update.js","../src/apply-changes.js","../src/finally-commit-all-changes.js","../src/get-local-changes-for-node/get-base-revision-and-max-client-revision.js","../src/combine-create-and-update.js","../src/combine-update-and-update.js","../src/merge-change.js","../src/get-local-changes-for-node/get-changes-since-revision.js","../src/get-local-changes-for-node/get-table-objects-as-changes.js","../src/get-local-changes-for-node/get-local-changes-for-node.js","../src/connect-protocol.js","../src/connect-fn.js","../src/Dexie.Syncable.js","../src/change_types.js","../src/statuses.js"],"names":["initSyncableConnect","db","connect","protocolInstance","protocolName","url","options","isOpen","_localSyncNode","Error","isMaster","id","table","where","above","first","masterNode","observable","sendMessage","wantReply","hasBeenClosed","Promise","reject","Dexie","DatabaseClosedError","hasFailed","InvalidStateError","resolve","on","_syncNodes","get","node","connectPromise","syncable","then","appliedRemoteRevision","open","catch","ex","PersistedContext","nodeID","otherProps","this","extend","prototype","save","vip","transaction","_changes","equalsIgnoreCase","initPersistedContext","syncContext","syncProtocol","syncOptions","put","SyncNode","myRevision","remoteBaseRevisions","type","lastHeartBeat","Date","now","dbUploadState","PersistedContext_1","initialUpload","toCollection","lastKey","currentRevision","add","enqueue","context","fn","instanceID","_enqueue","ongoingOperation","ignoreTransaction","finally","changes","remoteRevision","_uncommittedChanges","bulkAdd","map","change","changeWithNodeId","key","obj","mods","keys","c","anyOf","raw","each","cursor","primaryKey","updatesThatApply","filter","hasOwnProperty","objsToPut","curr","Object","forEach","keyPath","setByKeyPath","bulkPut","applyChanges","offset","length","i","firstChange","specifyKeys","schema","primKey","changesToApply","slice","changeType","CREATE","undefined","UPDATE","bulkUpdate","DELETE","bulkDelete","initApplyChanges","tablesToIncludeInTrans","tables","name","trans","currentTransaction","localRevisionBeforeChanges","orderBy","last","lastChange","rev","source","equals","toArray","uncommittedChanges","delete","currentLocalRevision","push","remote","local","splice","err","console","warn","stack","maxClientRevision","Infinity","remoteBaseRevision","prevChange","nextChange","clonedChange","deepClone","hadParentPath","parentPath","indexOf","substr","subPath","combineCreateAndUpdate","combineUpdateAndUpdate","hasMoreToGive","revision","maxChanges","maxRevision","cb","changeSet","numChanges","partial","ignoreSource","nextRevision","between","until","changeToSend","mergedChange","mergeChange","MAX_CHANGES_PER_CHUNK","getChangesSinceRevision","getTableObjectsAsChanges","state","collection","limitReached","item","currentTable","value","currentKey","tablesToUpload","brmcr","getBaseRevisionAndMaxClientRevision","localBaseRevision","additionalChanges","nodeModificationsOnAck","concat","shift","partialsThreshold","initGetChangesSinceRevision","initGetTableObjectsAsChanges","initConnectProtocol","dbAliveID","rejectConnectPromise","stillAlive","initEnqueue","activePeer","changeStatusTo","newStatus","status","statusChanged","fire","broadcastMessage","doSync","getLocalChangesForNode_autoAckIfEmpty","sendChangesToProvider","onChangesAccepted","finalSyncPromise","continueSendingChanges","p","asap","onError","error","again","isNaN","setTimeout","Statuses","SYNCING","abortTheProvider","ERROR_WILL_RETRY","connectedContinuation","disconnect","sync","applyRemoteChanges","continuation","ERROR","getLocalChangesForNode","autoAck","remoteChanges","saveToUncommittedChanges","initSaveToUncommittedChanges","finallyCommitAllChanges","initFinallyCommitAllChanges","react","e","continueUsingReactPattern","continueUsingPollPattern","onChanges","isWaitingForServer","changesWaiting","reactToChanges","ONLINE","message","unsubscribe","syncAgain","onSuccess","OFFLINE","initGetLocalChangesForNode","CONNECTING","activePeers","execConnect","connectProtocol","getOrCreateSyncNode","initGetOrCreateSyncNode","disconnected","Events","pos","existingPeer","peer","diffObject","getObjectDiff","Syncable","connectFn","initConnectFn","syncableConnect","msg","weBecameMaster","connectedRemoteNodes","all","and","getStatus","getOptions","list","a","modify","registeredProtocols","nodeIDsToDelete","nodes","nodeIDs","Observable","deleteOldChanges","unsyncedChanges","close","override","origClose","apply","arguments","defineProperty","enumerable","configurable","writable","_this","StatusTexts","-1","0","1","2","3","4","registerSyncProtocol","addons"],"mappings":"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","file":"dist/dexie-syncable.min.js","sourcesContent":["import Dexie from 'dexie';\n\nconst Promise = Dexie.Promise;\n\nexport default function initSyncableConnect(db, connect) {\n  return function syncableConnect(protocolInstance, protocolName, url, options) {\n    if (db.isOpen()) {\n      // Database is open\n      if (!db._localSyncNode)\n        throw new Error(\"Precondition failed: local sync node is missing. Make sure Dexie.Observable is active!\");\n\n      if (db._localSyncNode.isMaster) {\n        // We are master node\n        return connect(protocolInstance, protocolName, url, options, db._localSyncNode.id);\n      } else {\n        // We are not master node\n        // Request master node to do the connect:\n        return db.table('_syncNodes').where('isMaster').above(0).first(function (masterNode) {\n          // There will always be a master node. In theory we may self have become master node when we come here. But that's ok. We'll request ourselves.\n          return db.observable.sendMessage('connect', {\n            protocolName: protocolName,\n            url: url,\n            options: options\n          }, masterNode.id, {wantReply: true});\n        });\n      }\n    } else if (db.hasBeenClosed()) {\n      // Database has been closed.\n      return Promise.reject(new Dexie.DatabaseClosedError());\n    } else if (db.hasFailed()) {\n      // Database has failed to open\n      return Promise.reject(new Dexie.InvalidStateError(\n          \"Dexie.Syncable: Cannot connect. Database has failed to open\"));\n    } else {\n      // Database not yet open. It may be on its way to open, or open() hasn't yet been called.\n      // Wait for it to open, then connect.\n      var promise = new Promise(function (resolve, reject) {\n        db.on(\"ready\", () => {\n          // First, check if this is the very first time we connect to given URL.\n          // Need to know, because if it is, we should stall the promise returned to\n          // db.on('ready') to not be fulfilled until the initial sync has succeeded.\n          return db._syncNodes.get({url}, node => {\n            // Ok, now we know whether we should await the connect promise or not.\n            // No matter, we should now connect (will maybe create the SyncNode instance\n            // representing the given URL)\n            let connectPromise = db.syncable.connect(protocolName, url, options);\n            connectPromise.then(resolve, reject);// Resolve the returned promise when connected.\n            // Ok, so let's see if we should suspend DB queries until connected or not:\n            if (node && node.appliedRemoteRevision) {\n              // The very first initial sync has been done so we need not wait\n              // for the connect promise to complete. It can continue in background.\n              // Returning here will resume db.on('ready') and resume all queries that\n              // the application has put to the database.\n              return;\n            }\n            // This was the very first time we connect to the remote server,\n            // we must make sure that the initial sync request succeeeds before resuming\n            // database queries that the application code puts onto the database.\n            // If OFFLINE or other error, don't allow the application to proceed.\n            // We are assuming that an initial sync is essential for the application to\n            // function correctly.\n            return connectPromise;\n          });\n        });\n        // Force open() to happen. Otherwise connect() may stall forever.\n        db.open().catch(ex => {\n          // If open fails, db.on('ready') may not have been called and we must\n          // reject promise with InvalidStateError\n          reject(new Dexie.InvalidStateError(\n              `Dexie.Syncable: Couldn't connect. Database failed to open`,\n              ex\n          ));\n        });\n      });\n      return promise;\n    }\n  };\n}\n","import Dexie from 'dexie';\n\nexport default function initPersistedContext(node) {\n  //\n  // PersistedContext : IPersistedContext\n  //\n  return class PersistedContext {\n    constructor(nodeID, otherProps) {\n      this.nodeID = nodeID;\n      if (otherProps) Dexie.extend(this, otherProps);\n    }\n\n    save() {\n      // Store this instance in the syncContext property of the node it belongs to.\n      return Dexie.vip(() => {\n        return node.save();\n      });\n    }\n  }\n}\n","import Dexie from 'dexie';\n\nimport initPersistedContext from './PersistedContext';\n\nexport default function initGetOrCreateSyncNode(db, protocolName, url) {\n  return function getOrCreateSyncNode(options) {\n    return db.transaction('rw', db._syncNodes, db._changes, function () {\n      if (!url) throw new Error(\"Url cannot be empty\");\n\n      // Returning a promise from transaction scope will make the transaction promise resolve with the value of that promise.\n      return db._syncNodes.where(\"url\").equalsIgnoreCase(url).first(function (node) {\n        // If we found a node it will be instanceof SyncNode as Dexie.Observable\n        // maps to class\n        if (node) {\n          const PersistedContext = initPersistedContext(node);\n          // Node already there. Make syncContext become an instance of PersistedContext:\n          node.syncContext = new PersistedContext(node.id, node.syncContext);\n          node.syncProtocol = protocolName; // In case it was changed (would be very strange but...) could happen...\n          node.syncOptions = options; // Options could have been changed\n          db._syncNodes.put(node);\n        } else {\n          // Create new node and sync everything\n          node = new db.observable.SyncNode();\n          node.myRevision = -1;\n          node.appliedRemoteRevision = null;\n          node.remoteBaseRevisions = [];\n          node.type = \"remote\";\n          node.syncProtocol = protocolName;\n          node.url = url;\n          node.syncOptions = options;\n          node.lastHeartBeat = Date.now();\n          node.dbUploadState = null;\n          const PersistedContext = initPersistedContext(node);\n          Dexie.Promise.resolve(function () {\n            // If options.initialUpload is explicitely false, set myRevision to currentRevision.\n            if (options.initialUpload === false)\n              return db._changes.toCollection().lastKey(function (currentRevision) {\n                node.myRevision = currentRevision;\n              });\n          }()).then(function () {\n            db._syncNodes.add(node).then(function (nodeID) {\n              node.syncContext = new PersistedContext(nodeID); // Update syncContext in db with correct nodeId.\n              db._syncNodes.put(node);\n            });\n          });\n        }\n\n        return node; // returning node will make the db.transaction()-promise resolve with this value.\n      });\n    });\n  };\n}\n","import Dexie from 'dexie';\n\nexport default function initEnqueue(db) {\n  return function enqueue(context, fn, instanceID) {\n    function _enqueue() {\n      if (!context.ongoingOperation) {\n        context.ongoingOperation = Dexie.ignoreTransaction(function () {\n          return Dexie.vip(function () {\n            return fn();\n          });\n        }).finally(()=> {\n          delete context.ongoingOperation;\n        });\n      } else {\n        context.ongoingOperation = context.ongoingOperation.then(function () {\n          return enqueue(context, fn, instanceID);\n        });\n      }\n      return context.ongoingOperation;\n    }\n\n    if (!instanceID) {\n      // Caller wants to enqueue it until database becomes open.\n      if (db.isOpen()) {\n        return _enqueue();\n      } else {\n        return Dexie.Promise.reject(new Dexie.DatabaseClosedError());\n      }\n    } else if (db._localSyncNode && instanceID === db._localSyncNode.id) {\n      // DB is already open but queue doesn't want it to be queued if database has been closed (request bound to current instance of DB)\n      return _enqueue();\n    } else {\n      return Dexie.Promise.reject(new Dexie.DatabaseClosedError());\n    }\n  };\n}\n","export default function initSaveToUncommittedChanges(db, node) {\n  return function saveToUncommittedChanges(changes, remoteRevision) {\n    return db.transaction('rw!', db._uncommittedChanges, () => {\n      return db._uncommittedChanges.bulkAdd(changes.map(change => {\n        let changeWithNodeId = {\n          node: node.id,\n          type: change.type,\n          table: change.table,\n          key: change.key\n        };\n        if (change.obj) changeWithNodeId.obj = change.obj;\n        if (change.mods) changeWithNodeId.mods = change.mods;\n        return changeWithNodeId;\n      }));\n    }).then(() => {\n      node.appliedRemoteRevision = remoteRevision;\n      return node.save();\n    });\n  };\n}\n","import Dexie from 'dexie';\n\nexport default function bulkUpdate(table, changes) {\n  let keys = changes.map(c => c.key);\n  let map = {};\n  // Retrieve current object of each change to update and map each\n  // found object's primary key to the existing object:\n  return table.where(':id').anyOf(keys).raw().each((obj, cursor) => {\n    map[cursor.primaryKey+''] = obj;\n  }).then(()=>{\n    // Filter away changes whose key wasn't found in the local database\n    // (we can't update them if we do not know the existing values)\n    let updatesThatApply = changes.filter(c => map.hasOwnProperty(c.key+''));\n    // Apply modifications onto each existing object (in memory)\n    // and generate array of resulting objects to put using bulkPut():\n    let objsToPut = updatesThatApply.map (c => {\n      let curr = map[c.key+''];\n      Object.keys(c.mods).forEach(keyPath => {\n        Dexie.setByKeyPath(curr, keyPath, c.mods[keyPath]);\n      });\n      return curr;\n    });\n    return table.bulkPut(objsToPut);\n  });\n}\n","import Dexie from 'dexie';\nimport { CREATE, DELETE, UPDATE } from './change_types';\nimport bulkUpdate from './bulk-update';\n\nexport default function initApplyChanges(db) {\n  return function applyChanges(changes, offset) {\n    const length = changes.length;\n    // This is the base case for the recursion\n    if (offset >= length) return Dexie.Promise.resolve(null);\n    const firstChange = changes[offset];\n    let i, change;\n    for (i=offset + 1; i < length; ++i) {\n      change = changes[i];\n      if (change.type !== firstChange.type ||\n          change.table !== firstChange.table)\n        break;\n    }\n    const table = db.table(firstChange.table);\n    const specifyKeys = !table.schema.primKey.keyPath;\n    const changesToApply = changes.slice(offset, i);\n    const changeType = firstChange.type;\n    const bulkPromise =\n        changeType === CREATE ?\n            table.bulkPut(changesToApply.map(c => c.obj), specifyKeys ?\n                changesToApply.map(c => c.key) : undefined) :\n            changeType === UPDATE ?\n                bulkUpdate(table, changesToApply) :\n                changeType === DELETE ?\n                    table.bulkDelete(changesToApply.map(c => c.key)) :\n                    Dexie.Promise.resolve(null);\n\n    return bulkPromise.then(()=>applyChanges(changes, i));\n  };\n}\n","import Dexie from 'dexie';\nimport initApplyChanges from './apply-changes';\n\nexport default function initFinallyCommitAllChanges(db, node) {\n  const applyChanges = initApplyChanges(db);\n\n  return function finallyCommitAllChanges(changes, remoteRevision) {\n    // 1. Open a write transaction on all tables in DB\n    const tablesToIncludeInTrans = db.tables.filter(table => table.name === '_changes' ||\n      table.name === '_uncommittedChanges' ||\n      table.schema.observable);\n\n    return db.transaction('rw!', tablesToIncludeInTrans, () => {\n      var trans = Dexie.currentTransaction;\n      var localRevisionBeforeChanges = 0;\n      return db._changes.orderBy('rev').last(function (lastChange) {\n        // Store what revision we were at before committing the changes\n        localRevisionBeforeChanges = (lastChange && lastChange.rev) || 0;\n      }).then(() => {\n        // Specify the source. Important for the change consumer to ignore changes originated from self!\n        trans.source = node.id;\n        // 2. Apply uncommitted changes and delete each uncommitted change\n        return db._uncommittedChanges.where('node').equals(node.id).toArray();\n      }).then(function (uncommittedChanges) {\n        return applyChanges(uncommittedChanges, 0);\n      }).then(function () {\n        return db._uncommittedChanges.where('node').equals(node.id).delete();\n      }).then(function () {\n        // 3. Apply last chunk of changes\n        return applyChanges(changes, 0);\n      }).then(function () {\n        // Get what revision we are at now:\n        return db._changes.orderBy('rev').last();\n      }).then(function (lastChange) {\n        var currentLocalRevision = (lastChange && lastChange.rev) || 0;\n        // 4. Update node states (appliedRemoteRevision, remoteBaseRevisions and eventually myRevision)\n        node.appliedRemoteRevision = remoteRevision;\n        node.remoteBaseRevisions.push({remote: remoteRevision, local: currentLocalRevision});\n        if (node.myRevision === localRevisionBeforeChanges) {\n          // If server was up-to-date before we added new changes from the server, update myRevision to last change\n          // because server is still up-to-date! This is also important in order to prohibit getLocalChangesForNode() from\n          // ever sending an empty change list to server, which would otherwise be done every second time it would send changes.\n          node.myRevision = currentLocalRevision;\n        }\n        // Garbage collect remoteBaseRevisions not in use anymore:\n        if (node.remoteBaseRevisions.length > 1) {\n          for (var i = node.remoteBaseRevisions.length - 1; i > 0; --i) {\n            if (node.myRevision >= node.remoteBaseRevisions[i].local) {\n              node.remoteBaseRevisions.splice(0, i);\n              break;\n            }\n          }\n        }\n        // We are not including _syncNodes in transaction, so this save() call will execute in its own transaction.\n        node.save().catch(err=> {\n          console.warn(\"Dexie.Syncable: Unable to save SyncNode after applying remote changes: \" + (err.stack || err));\n        });\n      });\n    });\n  };\n}\n","export default function getBaseRevisionAndMaxClientRevision(node) {\n  /// <param name=\"node\" type=\"db.observable.SyncNode\"></param>\n  if (node.remoteBaseRevisions.length === 0)\n    return {\n      // No remoteBaseRevisions have arrived yet. No limit on clientRevision and provide null as remoteBaseRevision:\n      maxClientRevision: Infinity,\n      remoteBaseRevision: null\n    };\n  for (var i = node.remoteBaseRevisions.length - 1; i >= 0; --i) {\n    if (node.myRevision >= node.remoteBaseRevisions[i].local) {\n      // Found a remoteBaseRevision that fits node.myRevision. Return remoteBaseRevision and eventually a roof maxClientRevision pointing out where next remoteBaseRevision bases its changes on.\n      return {\n        maxClientRevision: i === node.remoteBaseRevisions.length - 1 ? Infinity : node.remoteBaseRevisions[i + 1].local,\n        remoteBaseRevision: node.remoteBaseRevisions[i].remote\n      };\n    }\n  }\n  // There are at least one item in the list but the server hasn't yet become up-to-date with the 0 revision from client.\n  return {\n    maxClientRevision: node.remoteBaseRevisions[0].local,\n    remoteBaseRevision: null\n  };\n}\n","import Dexie from 'dexie';\n\nexport default function combineCreateAndUpdate(prevChange, nextChange) {\n  var clonedChange = Dexie.deepClone(prevChange); // Clone object before modifying since the earlier change in db.changes[] would otherwise be altered.\n  Object.keys(nextChange.mods).forEach(function (keyPath) {\n    Dexie.setByKeyPath(clonedChange.obj, keyPath, nextChange.mods[keyPath]);\n  });\n  return clonedChange;\n}\n","import Dexie from 'dexie';\n\nexport default function combineUpdateAndUpdate(prevChange, nextChange) {\n  var clonedChange = Dexie.deepClone(prevChange); // Clone object before modifying since the earlier change in db.changes[] would otherwise be altered.\n  Object.keys(nextChange.mods).forEach(function (keyPath) {\n    // If prev-change was changing a parent path of this keyPath, we must update the parent path rather than adding this keyPath\n    var hadParentPath = false;\n    Object.keys(prevChange.mods).filter(function (parentPath) { return keyPath.indexOf(parentPath + '.') === 0; }).forEach(function (parentPath) {\n      Dexie.setByKeyPath(clonedChange.mods[parentPath], keyPath.substr(parentPath.length + 1), nextChange.mods[keyPath]);\n      hadParentPath = true;\n    });\n    if (!hadParentPath) {\n      // Add or replace this keyPath and its new value\n      clonedChange.mods[keyPath] = nextChange.mods[keyPath];\n    }\n    // In case prevChange contained sub-paths to the new keyPath, we must make sure that those sub-paths are removed since\n    // we must mimic what would happen if applying the two changes after each other:\n    Object.keys(prevChange.mods).filter(function (subPath) { return subPath.indexOf(keyPath + '.') === 0; }).forEach(function (subPath) {\n      delete clonedChange.mods[subPath];\n    });\n  });\n  return clonedChange;\n}\n","import { CREATE, UPDATE, DELETE } from './change_types';\nimport combineCreateAndUpdate from './combine-create-and-update.js';\nimport combineUpdateAndUpdate from './combine-update-and-update.js';\n\nexport default function mergeChange(prevChange, nextChange) {\n  switch (prevChange.type) {\n    case CREATE:\n      switch (nextChange.type) {\n        case CREATE:\n          return nextChange; // Another CREATE replaces previous CREATE.\n        case UPDATE:\n          return combineCreateAndUpdate(prevChange, nextChange); // Apply nextChange.mods into prevChange.obj\n        case DELETE:\n          return nextChange; // Object created and then deleted. If it wasnt for that we MUST handle resent changes, we would skip entire change here. But what if the CREATE was sent earlier, and then CREATE/DELETE at later stage? It would become a ghost object in DB. Therefore, we MUST keep the delete change! If object doesnt exist, it wont harm!\n      }\n      break;\n    case UPDATE:\n      switch (nextChange.type) {\n        case CREATE:\n          return nextChange; // Another CREATE replaces previous update.\n        case UPDATE:\n          return combineUpdateAndUpdate(prevChange, nextChange); // Add the additional modifications to existing modification set.\n        case DELETE:\n          return nextChange; // Only send the delete change. What was updated earlier is no longer of interest.\n      }\n      break;\n    case DELETE:\n      switch (nextChange.type) {\n        case CREATE:\n          return nextChange; // A resurection occurred. Only create change is of interest.\n        case UPDATE:\n          return prevChange; // Nothing to do. We cannot update an object that doesnt exist. Leave the delete change there.\n        case DELETE:\n          return prevChange; // Still a delete change. Leave as is.\n      }\n      break;\n  }\n}\n","import {CREATE, UPDATE} from '../change_types';\nimport mergeChange from '../merge-change';\n\nexport default function initGetChangesSinceRevision(db, node, hasMoreToGive) {\n  return function getChangesSinceRevision(revision, maxChanges, maxRevision, cb) {\n    /// <param name=\"cb\" value=\"function(changes, partial, nodeModificationsOnAck) {}\">Callback that will retrieve next chunk of changes and a boolean telling if it's a partial result or not. If truthy, result is partial and there are more changes to come. If falsy, these changes are the final result.</param>\n    var changeSet = {};\n    var numChanges = 0;\n    var partial = false;\n    var ignoreSource = node.id;\n    var nextRevision = revision;\n    return db.transaction('r', db._changes, function () {\n      var query = db._changes.where('rev').between(revision, maxRevision, false, true);\n      return query.until(() => {\n        if (numChanges === maxChanges) {\n          partial = true;\n          return true;\n        }\n      }).each(function (change) {\n        // Note the revision in nextRevision:\n        nextRevision = change.rev;\n        // change.source is set based on currentTransaction.source\n        if (change.source === ignoreSource) return;\n        // Our _changes table contains more info than required (old objs, source etc). Just make sure to include the necessary info:\n        var changeToSend = {\n          type: change.type,\n          table: change.table,\n          key: change.key\n        };\n        if (change.type === CREATE)\n          changeToSend.obj = change.obj;\n        else if (change.type === UPDATE)\n          changeToSend.mods = change.mods;\n\n        var id = change.table + \":\" + change.key;\n        var prevChange = changeSet[id];\n        if (!prevChange) {\n          // This is the first change on this key. Add it unless it comes from the source that we are working against\n          changeSet[id] = changeToSend;\n          ++numChanges;\n        } else {\n          // Merge the oldchange with the new change\n          var nextChange = changeToSend;\n          var mergedChange = mergeChange(prevChange, nextChange);\n          changeSet[id] = mergedChange;\n        }\n      });\n    }).then(function () {\n      var changes = Object.keys(changeSet).map(function (key) {\n        return changeSet[key];\n      });\n      hasMoreToGive.hasMoreToGive = partial;\n      return cb(changes, partial, {myRevision: nextRevision});\n    });\n  };\n}\n","import {CREATE} from '../change_types';\nimport getBaseRevisionAndMaxClientRevision from './get-base-revision-and-max-client-revision';\n\nexport default function initGetTableObjectsAsChanges(db, node, MAX_CHANGES_PER_CHUNK, getChangesSinceRevision, hasMoreToGive, cb) {\n  return function getTableObjectsAsChanges(state, changes, collection) {\n    /// <param name=\"state\" value=\"{tablesToUpload:[''],currentTable:'_changes',currentKey:null,localBaseRevision:0}\"></param>\n    /// <param name=\"changes\" type=\"Array\" elementType=\"IDatabaseChange\"></param>\n    /// <param name=\"collection\" type=\"db.Collection\"></param>\n    var limitReached = false;\n    return collection.until(function () {\n      if (changes.length === MAX_CHANGES_PER_CHUNK) {\n        limitReached = true;\n        return true;\n      }\n    }).each(function (item, cursor) {\n      changes.push({\n        type: CREATE,\n        table: state.currentTable,\n        key: cursor.key,\n        obj: cursor.value\n      });\n      state.currentKey = cursor.key;\n    }).then(function () {\n      if (limitReached) {\n        // Limit reached. Send partial result.\n        hasMoreToGive.hasMoreToGive = true;\n        return cb(changes, null, true, {dbUploadState: state});\n      } else {\n        // Done iterating this table. Check if there are more tables to go through:\n        if (state.tablesToUpload.length === 0) {\n          // Done iterating all tables\n          // Now append changes occurred during our dbUpload:\n          var brmcr = getBaseRevisionAndMaxClientRevision(node);\n          return getChangesSinceRevision(state.localBaseRevision, MAX_CHANGES_PER_CHUNK - changes.length, brmcr.maxClientRevision, function (additionalChanges, partial, nodeModificationsOnAck) {\n            changes = changes.concat(additionalChanges);\n            nodeModificationsOnAck.dbUploadState = null;\n            return cb(changes, brmcr.remoteBaseRevision, partial, nodeModificationsOnAck);\n          });\n        } else {\n          // Not done iterating all tables. Continue on next table:\n          state.currentTable = state.tablesToUpload.shift();\n          return getTableObjectsAsChanges(state, changes, db.table(state.currentTable).orderBy(':id'));\n        }\n      }\n    });\n  };\n}\n","import Dexie from 'dexie';\n\nimport getBaseRevisionAndMaxClientRevision from './get-base-revision-and-max-client-revision';\nimport initGetChangesSinceRevision from './get-changes-since-revision';\nimport initGetTableObjectsAsChanges from './get-table-objects-as-changes';\n\nexport default function initGetLocalChangesForNode(db, hasMoreToGive, partialsThreshold) {\n  var MAX_CHANGES_PER_CHUNK = partialsThreshold;\n\n  return function getLocalChangesForNode(node, cb) {\n    /// <summary>\n    ///     Based on given node's current revision and state, this function makes sure to retrieve next chunk of changes\n    ///     for that node.\n    /// </summary>\n    /// <param name=\"node\"></param>\n    /// <param name=\"cb\" value=\"function(changes, remoteBaseRevision, partial, nodeModificationsOnAck) {}\">Callback that will retrieve next chunk of changes and a boolean telling if it's a partial result or not. If truthy, result is partial and there are more changes to come. If falsy, these changes are the final result.</param>\n\n    const getChangesSinceRevision = initGetChangesSinceRevision(db, node, hasMoreToGive);\n    const getTableObjectsAsChanges = initGetTableObjectsAsChanges(db, node, MAX_CHANGES_PER_CHUNK, getChangesSinceRevision, hasMoreToGive, cb);\n\n    // Only a \"remote\" SyncNode created by Dexie.Syncable\n    // could not pass this test (remote nodes have myRevision: -1 on instantiation)\n    if (node.myRevision >= 0) {\n      // Node is based on a revision in our local database and will just need to get the changes that have occurred since that revision.\n      var brmcr = getBaseRevisionAndMaxClientRevision(node);\n      return getChangesSinceRevision(node.myRevision, MAX_CHANGES_PER_CHUNK, brmcr.maxClientRevision, function (changes, partial, nodeModificationsOnAck) {\n        return cb(changes, brmcr.remoteBaseRevision, partial, nodeModificationsOnAck);\n      });\n    } else {\n      // Node hasn't got anything from our local database yet. We will need to upload the entire DB to the node in the form of CREATE changes.\n      // Check if we're in the middle of already doing that:\n      if (node.dbUploadState === null) {\n        // Initialize dbUploadState\n        var tablesToUpload = db.tables.filter(function (table) {\n          return table.schema.observable;\n        }).map(function (table) {\n          return table.name;\n        });\n        if (tablesToUpload.length === 0) return Dexie.Promise.resolve(cb([], null, false, {})); // There are no synced tables at all.\n        var dbUploadState = {\n          tablesToUpload: tablesToUpload,\n          currentTable: tablesToUpload.shift(),\n          currentKey: null\n        };\n        return db._changes.orderBy('rev').last(function (lastChange) {\n          dbUploadState.localBaseRevision = (lastChange && lastChange.rev) || 0;\n          var collection = db.table(dbUploadState.currentTable).orderBy(':id');\n          return getTableObjectsAsChanges(dbUploadState, [], collection);\n        });\n      } else if (node.dbUploadState.currentKey) {\n        const collection = db.table(node.dbUploadState.currentTable).where(':id').above(node.dbUploadState.currentKey);\n        return getTableObjectsAsChanges(Dexie.deepClone(node.dbUploadState), [], collection);\n      } else {\n        const collection = db.table(dbUploadState.currentTable).orderBy(':id');\n        return getTableObjectsAsChanges(Dexie.deepClone(node.dbUploadState), [], collection);\n      }\n    }\n  };\n}\n","import Dexie from 'dexie';\n\nimport initEnqueue from './enqueue';\nimport initSaveToUncommittedChanges from './save-to-uncommitted-changes';\nimport initFinallyCommitAllChanges from './finally-commit-all-changes';\nimport initGetLocalChangesForNode from './get-local-changes-for-node/get-local-changes-for-node';\nimport {Statuses} from './statuses';\n\nconst Promise = Dexie.Promise;\n\nexport default function initConnectProtocol(db, protocolInstance, dbAliveID, options, rejectConnectPromise) {\n  const enqueue = initEnqueue(db);\n  var hasMoreToGive = {hasMoreToGive: true};\n\n  function stillAlive() {\n    // A better method than doing db.isOpen() because the same db instance may have been reopened, but then this sync call should be dead\n    // because the new instance should be considered a fresh instance and will have another local node.\n    return db._localSyncNode && db._localSyncNode.id === dbAliveID;\n  }\n\n  return function connectProtocol(node, activePeer) {\n    /// <param name=\"node\" type=\"db.observable.SyncNode\"></param>\n    const getLocalChangesForNode = initGetLocalChangesForNode(db, hasMoreToGive, protocolInstance.partialsThreshold);\n\n    const url = activePeer.url;\n\n    function changeStatusTo(newStatus) {\n      if (node.status !== newStatus) {\n        node.status = newStatus;\n        node.save().then(()=> {\n          db.syncable.on.statusChanged.fire(newStatus, url);\n          // Also broadcast message to other nodes about the status\n          db.observable.broadcastMessage(\"syncStatusChanged\", {newStatus: newStatus, url: url}, false);\n        }).catch('DatabaseClosedError', ()=> {\n        });\n      }\n    }\n\n    activePeer.on('disconnect', function (newStatus) {\n      if (!isNaN(newStatus)) changeStatusTo(newStatus);\n    });\n\n    var connectedContinuation;\n    changeStatusTo(Statuses.CONNECTING);\n    return doSync();\n\n    function doSync() {\n      // Use enqueue() to ensure only a single promise execution at a time.\n      return enqueue(doSync, function () {\n        // By returning the Promise returned by getLocalChangesForNode() a final catch() on the sync() method will also catch error occurring in entire sequence.\n        return getLocalChangesForNode_autoAckIfEmpty(node, sendChangesToProvider);\n      }, dbAliveID);\n    }\n\n    function sendChangesToProvider(changes, remoteBaseRevision, partial, nodeModificationsOnAck) {\n      // Create a final Promise for the entire sync() operation that will resolve when provider calls onSuccess().\n      // By creating finalPromise before calling protocolInstance.sync() it is possible for provider to call onError() immediately if it wants.\n      var finalSyncPromise = new Promise(function (resolve, reject) {\n        rejectConnectPromise.p = function (err) {\n          reject(err);\n        };\n        Dexie.asap(function () {\n          try {\n            protocolInstance.sync(\n                node.syncContext,\n                url,\n                options,\n                remoteBaseRevision,\n                node.appliedRemoteRevision,\n                changes,\n                partial,\n                applyRemoteChanges,\n                onChangesAccepted,\n                function (continuation) {\n                  resolve(continuation);\n                },\n                onError);\n          } catch (ex) {\n            onError(ex, Infinity);\n          }\n\n          function onError(error, again) {\n            reject(error);\n            if (stillAlive()) {\n              if (!isNaN(again) && again < Infinity) {\n                setTimeout(function () {\n                  if (stillAlive()) {\n                    changeStatusTo(Statuses.SYNCING);\n                    doSync().catch('DatabaseClosedError', abortTheProvider);\n                  }\n                }, again);\n                changeStatusTo(Statuses.ERROR_WILL_RETRY, error);\n                if (connectedContinuation && connectedContinuation.disconnect) connectedContinuation.disconnect();\n                connectedContinuation = null;\n              } else {\n                abortTheProvider(error); // Will fire ERROR on statusChanged event.\n              }\n            }\n          }\n        });\n      });\n\n      return finalSyncPromise.then(function () {\n        // Resolve caller of db.syncable.connect() with undefined. Not with continuation!\n        return undefined;\n      }).finally(()=> {\n        // In case error happens after connect, don't try reject the connect promise anymore.\n        // This is important. A Dexie unit test that verifies unhandled rejections will fail when Dexie.Syncable addon\n        // is active and this happens. It would fire unhandledrejection but that we do not want.\n        rejectConnectPromise.p = null;\n      });\n\n      function onChangesAccepted() {\n        Object.keys(nodeModificationsOnAck).forEach(function (keyPath) {\n          Dexie.setByKeyPath(node, keyPath, nodeModificationsOnAck[keyPath]);\n        });\n        // We dont know if onSuccess() was called by provider yet. If it's already called, finalPromise.then() will execute immediately,\n        // otherwise it will execute when finalSyncPromise resolves.\n        finalSyncPromise.then(continueSendingChanges);\n        return node.save();\n      }\n    }\n\n    function abortTheProvider(error) {\n      activePeer.disconnect(Statuses.ERROR, error);\n    }\n\n    function getLocalChangesForNode_autoAckIfEmpty(node, cb) {\n      return getLocalChangesForNode(node, function autoAck(changes, remoteBaseRevision, partial, nodeModificationsOnAck) {\n        if (changes.length === 0 && 'myRevision' in nodeModificationsOnAck && nodeModificationsOnAck.myRevision !== node.myRevision) {\n          Object.keys(nodeModificationsOnAck).forEach(function (keyPath) {\n            Dexie.setByKeyPath(node, keyPath, nodeModificationsOnAck[keyPath]);\n          });\n          node.save().catch('DatabaseClosedError', ()=> {\n          });\n          return getLocalChangesForNode(node, autoAck);\n        } else {\n          return cb(changes, remoteBaseRevision, partial, nodeModificationsOnAck);\n        }\n      });\n    }\n\n    function applyRemoteChanges(remoteChanges, remoteRevision, partial/*, clear*/) {\n      const saveToUncommittedChanges = initSaveToUncommittedChanges(db, node);\n      const finallyCommitAllChanges = initFinallyCommitAllChanges(db, node);\n\n      return enqueue(applyRemoteChanges, function () {\n        if (!stillAlive()) return Promise.reject(new Dexie.DatabaseClosedError());\n        // FIXTHIS: Check what to do if clear() is true!\n        return (partial ? saveToUncommittedChanges(remoteChanges, remoteRevision) : finallyCommitAllChanges(remoteChanges, remoteRevision))\n            .catch(function (error) {\n              abortTheProvider(error);\n              return Promise.reject(error);\n            });\n      }, dbAliveID);\n    }\n\n    //\n    //\n    //  Continuation Patterns Follows\n    //\n    //\n\n    function continueSendingChanges(continuation) {\n      if (!stillAlive()) { // Database was closed.\n        if (continuation.disconnect)\n          continuation.disconnect();\n        return;\n      }\n\n      connectedContinuation = continuation;\n      activePeer.on('disconnect', function () {\n        if (connectedContinuation) {\n          if (connectedContinuation.react) {\n            try {\n              // react pattern must provide a disconnect function.\n              connectedContinuation.disconnect();\n            } catch (e) {\n            }\n          }\n          connectedContinuation = null; // Stop poll() pattern from polling again and abortTheProvider() from being called twice.\n        }\n      });\n\n      if (continuation.react) {\n        continueUsingReactPattern(continuation);\n      } else {\n        continueUsingPollPattern(continuation);\n      }\n    }\n\n    //  React Pattern (eager)\n    function continueUsingReactPattern(continuation) {\n      var changesWaiting, // Boolean\n          isWaitingForServer; // Boolean\n\n\n      function onChanges() {\n        if (connectedContinuation) {\n          changeStatusTo(Statuses.SYNCING);\n          if (isWaitingForServer)\n            changesWaiting = true;\n          else {\n            reactToChanges();\n          }\n        }\n      }\n\n      db.on('changes', onChanges);\n\n      activePeer.on('disconnect', function () {\n        db.on.changes.unsubscribe(onChanges);\n      });\n\n      function reactToChanges() {\n        if (!connectedContinuation) return;\n        changesWaiting = false;\n        isWaitingForServer = true;\n        getLocalChangesForNode_autoAckIfEmpty(node, function (changes, remoteBaseRevision, partial, nodeModificationsOnAck) {\n          if (!connectedContinuation) return;\n          if (changes.length > 0) {\n            continuation.react(changes, remoteBaseRevision, partial, function onChangesAccepted() {\n              Object.keys(nodeModificationsOnAck).forEach(function (keyPath) {\n                Dexie.setByKeyPath(node, keyPath, nodeModificationsOnAck[keyPath]);\n              });\n              node.save().catch('DatabaseClosedError', ()=> {\n              });\n              // More changes may be waiting:\n              reactToChanges();\n            });\n          } else {\n            isWaitingForServer = false;\n            if (changesWaiting) {\n              // A change jumped in between the time-spot of quering _changes and getting called back with zero changes.\n              // This is an expreemely rare scenario, and eventually impossible. But need to be here because it could happen in theory.\n              reactToChanges();\n            } else {\n              changeStatusTo(Statuses.ONLINE);\n            }\n          }\n        }).catch(ex => {\n          console.error(`Got ${ex.message} caught by reactToChanges`);\n          abortTheProvider(ex);\n        });\n      }\n\n      reactToChanges();\n    }\n\n    //  Poll Pattern\n    function continueUsingPollPattern() {\n\n      function syncAgain() {\n        getLocalChangesForNode_autoAckIfEmpty(node, function (changes, remoteBaseRevision, partial, nodeModificationsOnAck) {\n\n          protocolInstance.sync(node.syncContext, url, options, remoteBaseRevision, node.appliedRemoteRevision, changes, partial, applyRemoteChanges, onChangesAccepted, onSuccess, onError);\n\n          function onChangesAccepted() {\n            Object.keys(nodeModificationsOnAck).forEach(function (keyPath) {\n              Dexie.setByKeyPath(node, keyPath, nodeModificationsOnAck[keyPath]);\n            });\n            node.save().catch('DatabaseClosedError', ()=> {\n            });\n          }\n\n          function onSuccess(continuation) {\n            if (!connectedContinuation) {\n              // Got disconnected before succeeding. Quit.\n              return;\n            }\n            connectedContinuation = continuation;\n            if (partial) {\n              // We only sent partial changes. Need to do another round asap.\n              syncAgain();\n            } else {\n              // We've sent all changes now (in sync!)\n              if (!isNaN(continuation.again) && continuation.again < Infinity) {\n                // Provider wants to keep polling. Set Status to ONLINE.\n                changeStatusTo(Statuses.ONLINE);\n                setTimeout(function () {\n                  if (connectedContinuation) {\n                    changeStatusTo(Statuses.SYNCING);\n                    syncAgain();\n                  }\n                }, continuation.again);\n              } else {\n                // Provider seems finished polling. Since we are never going to poll again,\n                // disconnect provider and set status to OFFLINE until another call to db.syncable.connect().\n                activePeer.disconnect(Statuses.OFFLINE);\n              }\n            }\n          }\n\n          function onError(error, again) {\n            if (!isNaN(again) && again < Infinity) {\n              if (connectedContinuation) {\n                setTimeout(function () {\n                  if (connectedContinuation) {\n                    changeStatusTo(Statuses.SYNCING);\n                    syncAgain();\n                  }\n                }, again);\n                changeStatusTo(Statuses.ERROR_WILL_RETRY);\n              } // else status is already changed since we got disconnected.\n            } else {\n              abortTheProvider(error); // Will fire ERROR on onStatusChanged.\n            }\n          }\n        }).catch(abortTheProvider);\n      }\n\n      if (hasMoreToGive.hasMoreToGive) {\n        syncAgain();\n      } else if (connectedContinuation && !isNaN(connectedContinuation.again) && connectedContinuation.again < Infinity) {\n        changeStatusTo(Statuses.ONLINE);\n        setTimeout(function () {\n          if (connectedContinuation) {\n            changeStatusTo(Statuses.SYNCING);\n            syncAgain();\n          }\n        }, connectedContinuation.again);\n      } else {\n        // Provider seems finished polling. Since we are never going to poll again,\n        // disconnect provider and set status to OFFLINE until another call to db.syncable.connect().\n        activePeer.disconnect(Statuses.OFFLINE);\n      }\n    }\n  };\n}\n","import Dexie from 'dexie';\n\nimport initGetOrCreateSyncNode from './get-or-create-sync-node';\nimport initConnectProtocol from './connect-protocol';\nimport {Statuses} from './statuses';\n\nexport default function initConnectFn(db, activePeers) {\n  return function connect(protocolInstance, protocolName, url, options, dbAliveID) {\n    /// <param name=\"protocolInstance\" type=\"ISyncProtocol\"></param>\n    var existingPeer = activePeers.filter(function (peer) {\n      return peer.url === url;\n    });\n    if (existingPeer.length > 0) {\n      const activePeer = existingPeer[0];\n      const diffObject = {};\n      Dexie.getObjectDiff(activePeer.syncOptions, options, diffObject);\n      // Options have been changed\n      // We need to disconnect and reconnect\n      if (Object.keys(diffObject).length !== 0) {\n        return db.syncable.disconnect(url)\n          .then(() => {\n            return execConnect();\n          })\n      } else {\n        // Never create multiple syncNodes with same protocolName and url. Instead, let the next call to connect() return the same promise that\n        // have already been started and eventually also resolved. If promise has already resolved (node connected), calling existing promise.then() will give a callback directly.\n        return existingPeer[0].connectPromise;\n      }\n    }\n\n    function execConnect() {\n      // Use an object otherwise we wouldn't be able to get the reject promise from\n      // connectProtocol\n      var rejectConnectPromise = {p: null};\n      const connectProtocol = initConnectProtocol(db, protocolInstance, dbAliveID, options, rejectConnectPromise);\n      const getOrCreateSyncNode = initGetOrCreateSyncNode(db, protocolName, url);\n      var connectPromise = getOrCreateSyncNode(options).then(function (node) {\n        return connectProtocol(node, activePeer);\n      });\n\n      var disconnected = false;\n      var activePeer = {\n        url: url,\n        status: Statuses.OFFLINE,\n        connectPromise: connectPromise,\n        syncOptions: options,\n        on: Dexie.Events(null, \"disconnect\"),\n        disconnect: function (newStatus, error) {\n          var pos = activePeers.indexOf(activePeer);\n          if (pos >= 0) activePeers.splice(pos, 1);\n          if (error && rejectConnectPromise.p) rejectConnectPromise.p(error);\n          if (!disconnected) {\n            activePeer.on.disconnect.fire(newStatus, error);\n          }\n          disconnected = true;\n        }\n      };\n      activePeers.push(activePeer);\n\n      return connectPromise;\n    }\n\n    return execConnect();\n  };\n}\n","/* ========================================================================== \n *                           dexie-syncable.js\n * ==========================================================================\n *\n * Dexie addon for syncing indexedDB with remote endpoints.\n *\n * By David Fahlander, david.fahlander@gmail.com,\n *    Nikolas Poniros, https://github.com/nponiros\n *\n * ==========================================================================\n *\n * Version {version}, {date}\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n * \n */\n\nimport Dexie from \"dexie\";\n// Depend on 'dexie-observable'\n// To support both ES6,AMD,CJS and UMD (plain script), we just import it and then access it as \"Dexie.Observable\".\n// That way, our plugin works in all UMD cases.\n// If target platform would only be module based (ES6/AMD/CJS), we could have done 'import Observable from \"dexie-observable\"'.\nimport \"dexie-observable\";\n\nimport initSyncableConnect from './syncable-connect';\nimport initConnectFn from './connect-fn';\nimport {Statuses, StatusTexts} from './statuses';\n\nvar override = Dexie.override,\n    Promise = Dexie.Promise,\n    Observable = Dexie.Observable;\n\nexport default function Syncable (db) {\n    /// <param name=\"db\" type=\"Dexie\"></param>\n\n    var activePeers = [];\n\n    const connectFn = initConnectFn(db, activePeers);\n    const syncableConnect = initSyncableConnect(db, connectFn);\n\n    db.on('message', function(msg) {\n        // Message from other local node arrives...\n        Dexie.vip(function() {\n            if (msg.type === 'connect') {\n                // We are master node and another non-master node wants us to do the connect.\n                db.syncable.connect(msg.message.protocolName, msg.message.url, msg.message.options).then(msg.resolve, msg.reject);\n            } else if (msg.type === 'disconnect') {\n                db.syncable.disconnect(msg.message.url).then(msg.resolve, msg.reject);\n            } else if (msg.type === 'syncStatusChanged') {\n                // We are client and a master node informs us about syncStatus change.\n                // Lookup the connectedProvider and call its event\n                db.syncable.on.statusChanged.fire(msg.message.newStatus, msg.message.url);\n            }\n        });\n    });\n\n    db.on('cleanup', function(weBecameMaster) {\n        // A cleanup (done in Dexie.Observable) may result in that a master node is removed and we become master.\n        if (weBecameMaster) {\n            // We took over the master role in Observable's cleanup method.\n            // We should connect to remote servers now.\n            // At this point, also reconnect servers with status ERROR_WILL_RETRY as well as plain ERROR.\n            // Reason to reconnect to those with plain \"ERROR\" is that the ERROR state may occur when a database\n            // connection has been closed. The new master would then be expected to reconnect.\n            // Also, this is not an infinite poll(). This is rare event that a new browser tab takes over from\n            // an old closed one. \n            Dexie.ignoreTransaction(()=>Dexie.vip(()=>{\n                return db._syncNodes.where({type: 'remote'})\n                    .filter(node => node.status !== Statuses.OFFLINE)\n                    .toArray(connectedRemoteNodes => Promise.all(connectedRemoteNodes.map(node => \n                        db.syncable.connect(node.syncProtocol, node.url, node.syncOptions).catch(e => {\n                            console.warn(`Dexie.Syncable: Could not connect to ${node.url}. ${e.stack || e}`);\n                        })\n                    )));\n            })).catch('DatabaseClosedError', ()=>{});\n        }\n    });\n\n    // \"ready\" subscriber for the master node that makes sure it will always connect to sync server\n    // when the database opens. It will not wait for the connection to complete, just initiate the\n    // connection so that it will continue syncing as long as the database is open.\n\n    // Dexie.Observable's 'ready' subscriber will have been invoked prior to this, making sure\n    // that db._localSyncNode exists and persisted before this subscriber kicks in.\n    db.on('ready', function onReady() {\n        // Again, in onReady: If we ARE master, make sure to connect to remote servers that is in a connected state.\n        if (db._localSyncNode && db._localSyncNode.isMaster) {\n            // Make sure to connect to remote servers that is in a connected state (NOT OFFLINE or ERROR!)\n            // This \"ready\" subscriber will never be the one performing the initial sync request, because\n            // even after calling db.syncable.connect(), there won't exist any \"remote\" sync node yet.\n            // Instead, db.syncable.connect() will subscribe to \"ready\" also, and that subscriber will be\n            // called after this one. There, in that subscriber, the initial sync request will take place\n            // and the \"remote\" node will be created so that this \"ready\" subscriber can auto-connect the\n            // next time this database is opened.\n            // CONCLUSION: We can always assume that the local DB has been in sync with the server at least\n            // once in the past for each \"connectedRemoteNode\" we find in query below.\n\n            // Don't halt db.ready while connecting (i.e. we do not return a promise here!)\n            db._syncNodes\n                .where('type').equals('remote')\n                .and(node => node.status !== Statuses.OFFLINE)\n                .toArray(connectedRemoteNodes => {\n                    // There are connected remote nodes that we must manage (or take over to manage)\n                    connectedRemoteNodes.forEach(\n                            node => db.syncable.connect(\n                                node.syncProtocol,\n                                node.url,\n                                node.syncOptions)     \n                            .catch (()=>{}) // A failure will be triggered in on('statusChanged'). We can ignore.\n                    );\n                }).catch('DatabaseClosedError', ()=>{});\n        }\n    }, true); // True means the ready event will survive a db reopen - db.close()/db.open()\n\n    db.syncable = {};\n\n    db.syncable.getStatus = function(url, cb) {\n        if (db.isOpen()) {\n            return Dexie.vip(function() {\n                return db._syncNodes.where('url').equals(url).first(function(node) {\n                    return node ? node.status : Statuses.OFFLINE;\n                });\n            }).then(cb);\n        } else {\n            return Promise.resolve(Syncable.Statuses.OFFLINE).then(cb);\n        }\n    };\n\n    db.syncable.getOptions = function(url, cb) {\n        return db.transaction('r?', db._syncNodes, () => {\n            return db._syncNodes.where('url').equals(url).first(function(node) {\n                return node.syncOptions;\n            }).then(cb);\n        });\n    };\n\n    db.syncable.list = function() {\n        return db.transaction('r?', db._syncNodes, ()=>{\n            return db._syncNodes.where('type').equals('remote').toArray(function(a) {\n                return a.map(function(node) { return node.url; });\n            });\n        });\n    };\n\n    db.syncable.on = Dexie.Events(db, { statusChanged: \"asap\" });\n\n    db.syncable.disconnect = function(url) {\n        return Dexie.ignoreTransaction(()=>{\n            return Promise.resolve().then(()=>{\n                if (db._localSyncNode && db._localSyncNode.isMaster) {\n                    return Promise.all(activePeers.filter(peer => peer.url === url).map(peer => {\n                        return peer.disconnect(Statuses.OFFLINE);\n                    }));\n                } else {\n                    return db._syncNodes.where('isMaster').above(0).first(masterNode => {\n                        return db.observable.sendMessage('disconnect', { url: url }, masterNode.id, {wantReply: true});\n                    });\n                }\n            }).then(()=>{\n                return db._syncNodes.where(\"url\").equals(url).modify(node => {\n                    node.status = Statuses.OFFLINE;\n                });\n            });\n        });\n    };\n\n    db.syncable.connect = function(protocolName, url, options) {\n        options = options || {}; // Make sure options is always an object because 1) Provider expects it to be. 2) We'll be persisting it and you cannot persist undefined.\n        var protocolInstance = Syncable.registeredProtocols[protocolName];\n        if (protocolInstance) {\n            return syncableConnect(protocolInstance, protocolName, url, options);\n        } else {\n            return Promise.reject(\n                new Error(\"ISyncProtocol '\" + protocolName + \"' is not registered in Dexie.Syncable.registerSyncProtocol()\")\n            );\n        }\n    };\n\n    db.syncable.delete = function(url) {\n        return db.syncable.disconnect(url).then(()=>{\n            return db.transaction('rw!', db._syncNodes, db._changes, db._uncommittedChanges, ()=>{\n                // Find the node(s)\n                // Several can be found, as detected by @martindiphoorn,\n                // let's delete them and cleanup _uncommittedChanges and _changes \n                // accordingly.\n                let nodeIDsToDelete;\n                return db._syncNodes\n                    .where(\"url\").equals(url)\n                    .toArray(nodes => nodes.map(node => node.id))\n                    .then(nodeIDs => {\n                        nodeIDsToDelete = nodeIDs;\n                        // Delete the syncNode that represents the remote endpoint.\n                        return db._syncNodes.where('id').anyOf(nodeIDs).delete()\n                    })\n                    .then (() =>\n                        // In case there were uncommittedChanges belonging to this, delete them as well\n                        db._uncommittedChanges.where('node').anyOf(nodeIDsToDelete).delete());\n            }).then(()=> {\n                // Spawn background job to delete old changes, now that a node has been deleted,\n                // there might be changes in _changes table that is not needed to keep anymore.\n                // This is done in its own transaction, or possible several transaction to prohibit\n                // starvation\n                Observable.deleteOldChanges(db);\n            });\n        });\n    };\n\n    db.syncable.unsyncedChanges = function(url) {\n        return db._syncNodes.where(\"url\").equals(url).first(function(node) {\n            return db._changes.where('rev').above(node.myRevision).toArray();\n        });\n    };\n\n    db.close = override(db.close, function(origClose) {\n        return function() {\n            activePeers.forEach(function(peer) {\n                peer.disconnect();\n            });\n            return origClose.apply(this, arguments);\n        };\n    });\n\n    Object.defineProperty(\n        db.observable.SyncNode.prototype,\n        'save', {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value() {\n                return db.transaction('rw?', db._syncNodes, () => {\n                    return db._syncNodes.put(this);\n            });\n        }\n     });\n}\n\nSyncable.Statuses = Statuses;\n\nSyncable.StatusTexts = StatusTexts;\n\nSyncable.registeredProtocols = {}; // Map<String,ISyncProviderFactory> when key is the provider name.\n\nSyncable.registerSyncProtocol = function(name, protocolInstance) {\n    /// <summary>\n    ///    Register a synchronization protocol that can synchronize databases with remote servers.\n    /// </summary>\n    /// <param name=\"name\" type=\"String\">Provider name</param>\n    /// <param name=\"protocolInstance\" type=\"ISyncProtocol\">Implementation of ISyncProtocol</param>\n    const partialsThreshold = protocolInstance.partialsThreshold;\n    if (typeof partialsThreshold === 'number') {\n        // Don't allow NaN or negative threshold\n        if (isNaN(partialsThreshold) || partialsThreshold < 0) {\n            throw new Error('The given number for the threshold is not supported');\n        }\n        // If the threshold is 0 we will not send any client changes but will get server changes\n    } else {\n        // Use Infinity as the default so simple protocols don't have to care about partial synchronization\n        protocolInstance.partialsThreshold = Infinity;\n    }\n    Syncable.registeredProtocols[name] = protocolInstance;\n};\n\n// Register addon in Dexie:\nDexie.Syncable = Syncable;\nDexie.addons.push(Syncable);\n","// Change Types\nexport const CREATE = 1;\nexport const UPDATE = 2;\nexport const DELETE = 3;\n","export const Statuses = {\n  ERROR: -1, // An irreparable error occurred and the sync provider is dead.\n  OFFLINE: 0, // The sync provider hasn't yet become online, or it has been disconnected.\n  CONNECTING: 1, // Trying to connect to server\n  ONLINE: 2, // Connected to server and currently in sync with server\n  SYNCING: 3, // Syncing with server. For poll pattern, this is every poll call. For react pattern, this is when local changes are being sent to server.\n  ERROR_WILL_RETRY: 4 // An error occurred such as net down but the sync provider will retry to connect.\n};\n\nexport const StatusTexts = {\n  \"-1\": \"ERROR\",\n  \"0\": \"OFFLINE\",\n  \"1\": \"CONNECTING\",\n  \"2\": \"ONLINE\",\n  \"3\": \"SYNCING\",\n  \"4\": \"ERROR_WILL_RETRY\"\n};\n"]}